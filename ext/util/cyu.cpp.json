{
  "double_consume_buffer": {
    "prefix": "double_consume_buffer",
    "description": "double_consume_buffer",
    "body": [
      "namespace ext {",
      "template <typename DataStruture>",
      "class ConsumerBase {",
      " public:",
      "  virtual void Consume(const std::shared_ptr<DataStruture>& consume_buffer) = 0;",
      "  virtual void Clear(const std::shared_ptr<DataStruture>& consume_buffer) {}",
      "};",
      "template <typename DataStrutrue, typename Consumer = ConsumerBase<DataStrutrue>>",
      "class DoubleConsumeBuffer {",
      " public:",
      "  template <typename... Args>",
      "  DoubleConsumeBuffer(uint32_t loop_ms, const Args&... args) :",
      "      buffer_({std::make_shared<DataStrutrue>(args...), std::make_shared<DataStrutrue>(args...)}),",
      "      is_stop_(false),",
      "      write_buffer_index_(0),",
      "      loop_ms_(loop_ms),",
      "      consume_thread_(Run, this)",
      "  {",
      "  }",
      "  std::shared_ptr<DataStrutrue> GetWriteBuffer() {",
      "    bool index = write_buffer_index_;",
      "    bool locked = lock_[index].try_lock_shared();",
      "    while (!locked) {",
      "      index = write_buffer_index_;",
      "      locked = lock_[index].try_lock_shared();",
      "    }",
      "    return SharedPtr<DataStrutrue>(buffer_[index], &lock_[index]);",
      "  }",
      " protected:",
      "  template <typename Type>",
      "  class SharedPtr : public std::shared_ptr<Type> {",
      "   private:",
      "    SharedPtr(const std::shared_ptr<Type>& ptr, std::shared_mutex* lock) : std::shared_ptr<Type>(ptr) {",
      "      lock_ = lock;",
      "    }",
      "    ~SharedPtr() {",
      "      lock_->unlock_shared();",
      "    }",
      "    std::shared_mutex* lock_;",
      "    friend class DoubleConsumeBuffer;",
      "  };",
      "  static void Run(DoubleConsumeBuffer* self) {",
      "    while (!self->is_stop_) {",
      "      bool index = self->write_buffer_index_;",
      "      {",
      "        self->write_buffer_index_ = !self->write_buffer_index_;",
      "        std::unique_lock<std::shared_mutex>(self->lock_[index]);",
      "        self->consumer_.Consume(self->buffer_[index]);",
      "        self->consumer_.Clear(self->buffer_[index]);",
      "      }",
      "      std::this_thread::sleep_for(std::chrono::milliseconds(self->loop_ms_));",
      "    }",
      "  }",
      "  std::shared_ptr<DataStrutrue> buffer_[2];",
      "  bool is_stop_;",
      "  bool write_buffer_index_;",
      "  uint32_t loop_ms_;",
      "  std::thread consume_thread_;",
      "  Consumer consumer_;",
      "  std::shared_mutex lock_[2];",
      "};",
      "}  // namespace ext"
    ]
  },
  "io": {
    "prefix": "io",
    "description": "io",
    "body": [
      "namespace ext {",
      "namespace detail {",
      "  const size_t buflen = (1 << 21) + 1;",
      "  char buf[buflen], *st = nullptr, *ed = nullptr;",
      "  inline char gc() { return ((st == ed) ? (st = buf, ed = st + fread(buf, 1, buflen, stdin), (st == ed) ? EOF : *st++) : *st++); }",
      "  inline bool blank(char c) { return c == ' ' || c == '-' || c == '\\n' || c == '\\t' || c == '\\r'; }",
      "  template <typename T> inline bool Re(T &x) {",
      "    char c; int f = 1;",
      "    while (blank(c = gc())) if (c == '-') f = -1;",
      "    if (c == EOF) return false;",
      "    for (x = c - '0'; (c = gc()) >= '0' && c <= '9'; x = x * 10 + c - '0');",
      "    x *= f; return true;",
      "  }",
      "  char obuf[buflen], *_ptr = obuf, *_oed = obuf + buflen - 1, _stk[55];",
      "  int _top;",
      "  void flush() { fwrite(obuf, 1, _ptr - obuf, stdout); _ptr = obuf;}",
      "  void pc(char c) { *(_ptr++) = c; if (_ptr == _oed) flush(); }",
      "  template <typename T> inline void Pr(T x) {",
      "    if (x == 0) { pc('0'); return; }",
      "    if (x < 0) { pc('-'); x = -x; }",
      "    for (_top = 0; x > 0; _top++, x /= 10) _stk[_top] = (x % 10) + '0';",
      "    while (_top > 0) pc(_stk[--_top]);",
      "  }",
      "  template <typename T> inline void Prln(T x) { Pr(x); pc('\\n'); }",
      "  struct _IOflusher_ { ~_IOflusher_() { flush(); } } __flusher__;",
      "}  // namespace detail",
      "struct instream {",
      "  instream &operator>>(char &__n) { __n = detail::gc(); return *this; }",
      "  instream &operator>>(unsigned char &__n) { __n = detail::gc(); return *this; }",
      "  instream &operator>>(short &__n) { detail::Re(__n); return *this; }",
      "  instream &operator>>(unsigned short &__n) { detail::Re(__n); return *this; }",
      "  instream &operator>>(int &__n) { detail::Re(__n); return *this; }",
      "  instream &operator>>(unsigned int &__n) { detail::Re(__n); return *this; }",
      "  instream &operator>>(long &__n) { detail::Re(__n); return *this; }",
      "  instream &operator>>(unsigned long &__n) { detail::Re(__n); return *this; }",
      "  instream &operator>>(long long &__n) { detail::Re(__n); return *this; }",
      "  instream &operator>>(unsigned long long &__n) { detail::Re(__n); return *this; }",
      "#ifdef __SIZEOF_INT128__",
      "  instream &operator>>(__int128 &__n) { detail::Re(__n); return *this;}",
      "  instream &operator>>(__uint128_t &__n) { detail::Re(__n); return *this; }",
      "#endif",
      "  instream &operator>>(std::string &__n) {",
      "    __n.clear();",
      "    char c = detail::gc();",
      "    if(c == EOF) return *this;",
      "    while(c != EOF && detail::blank(c)) c = detail::gc();",
      "    if(c == EOF) return *this;",
      "    while(c != EOF && !detail::blank(c)) {",
      "      __n.push_back(c);",
      "      c = detail::gc();",
      "    }",
      "    if(c != EOF) detail::st--;",
      "    return *this;",
      "  }",
      "} in;",
      "struct outstream {",
      "  outstream &operator<<(const char &__n) { detail::pc(__n); return *this; }",
      "  outstream &operator<<(const unsigned char &__n) { detail::pc(__n); return *this; }",
      "  outstream &operator<<(const short &__n) { detail::Pr(__n); return *this; }",
      "  outstream &operator<<(const unsigned short &__n) { detail::Pr(__n); return *this; }",
      "  outstream &operator<<(const int &__n) { detail::Pr(__n); return *this; }",
      "  outstream &operator<<(const unsigned int &__n) { detail::Pr(__n); return *this; }",
      "  outstream &operator<<(const long &__n) { detail::Pr(__n); return *this; }",
      "  outstream &operator<<(const unsigned long &__n) { detail::Pr(__n); return *this; }",
      "  outstream &operator<<(const long long &__n) { detail::Pr(__n); return *this; }",
      "  outstream &operator<<(const unsigned long long &__n) { detail::Pr(__n); return *this; }",
      "#ifdef __SIZEOF_INT128__",
      "  outstream &operator<<(const __int128 &__n) { detail::Pr(__n); return *this; }",
      "  outstream &operator<<(const __uint128_t &__n) { detail::Pr(__n); return *this; }",
      "#endif",
      "  outstream &operator<<(const std::string &__n) {",
      "    for(const char &__c: __n) detail::pc(__c);",
      "    return *this;",
      "  }",
      "} out;",
      "}  // namespace ext"
    ]
  },
  "dsu": {
    "prefix": "dsu",
    "description": "dsu",
    "body": [
      "namespace ext {",
      "",
      "// 并查集",
      "class Dsu {",
      " public:",
      "  std::vector<int> anc, size;",
      "  Dsu(int n) : anc(n), size(n, 0) {",
      "    std::iota(anc.begin(), anc.end(), 0);",
      "  }",
      "  int operator[] (int x) {",
      "    return x == anc[x] ? x : anc[x] = operator[](anc[x]);",
      "  }",
      "  bool operator() (int u, int v) {",
      "    int a = operator[](u), b = operator[](v);",
      "    if (a == b) return false;",
      "    if (size[a] < size[b]) anc[a] = b;",
      "    else anc[b] = a, size[a] += (size[a] == size[b]);",
      "    return true;",
      "  }",
      "};",
      "",
      "}  // namespace ext"
    ]
  },
  "fenwick_tree": {
    "prefix": "fenwick_tree",
    "description": "fenwick_tree",
    "body": [
      "namespace ext {",
      "",
      "// 树状数组",
      "// index from 1",
      "template<typename Type = int>",
      "class FenwickTree {",
      " public:",
      "  FenwickTree(const int size) {",
      "    std::vector<Type> vec(size, Type());",
      "    Init(vec);",
      "  }",
      "  FenwickTree(const int size, const Type& init_value) {",
      "    std::vector<Type> vec(size, init_value);",
      "    Init(vec);",
      "  }",
      "  FenwickTree(const std::vector<Type>& vec) {",
      "    Init(vec);",
      "  }",
      "  void Add(int position, const Type& value) {",
      "    for (int i = position; i <= n_; i += i & (-i)) {",
      "      fenwick_tree_[i] += value;",
      "    }",
      "  }",
      "  Type Query(int index) const {",
      "    Type ret = Type();",
      "    for (int i = index; i > 0; i -= i & (-i)) {",
      "      ret += fenwick_tree_[i];",
      "    }",
      "    return ret;",
      "  }",
      "  Type Query(int left, int right) const {",
      "    return Query(right) - Query(left - 1);",
      "  }",
      " private:",
      "  void Init(const std::vector<Type>& vec) {",
      "    n_ = vec.size();",
      "    fenwick_tree_.resize(vec.size() + 1);",
      "    for (int i = 1; i <= n_; i++) {",
      "      Add(i, vec[i - 1]);",
      "    }",
      "  }",
      "  int n_;",
      "  std::vector<Type> fenwick_tree_;",
      "};",
      "",
      "}  // namespace ext"
    ]
  },
  "s_table": {
    "prefix": "s_table",
    "description": "s_table",
    "body": [
      "namespace ext {",
      "",
      "namespace detail {",
      "",
      "template <typename Type, typename Comp = std::less<Type>>",
      "class InnerMerger {",
      " public:",
      "  Type operator()(const Type& lhs, const Type& rhs) const {",
      "    return cmp(lhs, rhs) ? lhs : rhs;",
      "  }",
      " private:",
      "  const Comp cmp;",
      "};",
      "",
      "}  // namespace detail",
      "",
      "template<typename Type, typename Merger = detail::InnerMerger<Type>>",
      "class STable {",
      " public:",
      "  explicit STable(const vector<Type>& arr) : merger() {",
      "    const int n = static_cast<int>(arr.size());",
      "    table.assign(n, vector<Type>(Log2(n) + 1));",
      "    for (int i = 0; i < n; i++) {",
      "      table[i][0] = arr[i];",
      "    }",
      "    for (int j = 1; (1 << j) <= n; j++) {",
      "      for (int i = 0; i + (1 << j) - 1 < n; i++) {",
      "        const Type x = table[i][j - 1], y = table[i + (1 << (j - 1))][j - 1];",
      "        table[i][j] = merger(x, y);",
      "      }",
      "    }",
      "  }",
      "  Type Query(int l, int r) const {",
      "    const int k = Log2(r - l + 1);",
      "    const Type x = table[l][k], y = table[r - (1 << k) + 1][k];",
      "    return merger(x, y);",
      "  }",
      "  Type operator()(int l, int r) const {",
      "    return Query(l, r);",
      "  }",
      " private:",
      "  int Log2(int n) const {",
      "    return 31 - __builtin_clz(static_cast<unsigned int>(n));",
      "  }",
      "  const Merger merger;",
      "  std::vector<std::vector<Type>> table;",
      "};",
      "",
      "}  // namespace ext"
    ]
  },
  "combine": {
    "prefix": "combine",
    "description": "combine",
    "body": [
      "namespace ext {",
      "",
      "class Combine {",
      " public:",
      "  Combine(int mod, int max_size) : mod_(mod), max_size_(max_size + 5) {",
      "    fac_.resize(max_size_);",
      "    inv_.resize(max_size_);",
      "    fac_[0] = 1;",
      "    for (int i = 1; i < max_size_; i++) {",
      "      fac_[i] = 1ll * fac_[i - 1] * i % mod;",
      "    }",
      "    inv_[max_size_ - 1] = std::get<0>(ExGcd(fac_[max_size_ - 1], mod_));",
      "    if (inv_[max_size_ - 1] < 0) {",
      "      inv_[max_size_ - 1] += mod_;",
      "    }",
      "    for (int i = max_size_ - 2; i >= 0; i--) {",
      "      inv_[i] = 1ll * inv_[i + 1] * (i + 1) % mod_;",
      "    }",
      "  }",
      "  int GetFac(int index) {",
      "    return fac_[index];",
      "  }",
      "  int GetInv(int index) {",
      "    return inv_[index];",
      "  }",
      "  int operator()(int n, int m) {",
      "    return 1ll * fac_[n] * inv_[m] % mod_ * inv_[n - m] % mod_;",
      "  }",
      " private:",
      "  const int mod_;",
      "  const int max_size_;",
      "  std::vector<int> fac_, inv_;",
      "};",
      "",
      "}  // namespace ext"
    ]
  },
  "crt": {
    "prefix": "crt",
    "description": "crt",
    "body": [
      "namespace ext {",
      "",
      "// v里每个std::pair<Type, Type>中first为被模数，second为模数",
      "template<typename Type>",
      "std::pair<Type, Type> Crt(const std::vector<std::pair<Type, Type>>& v) {",
      "  Type a = 1, r = 0;",
      "  const int n = v.size();",
      "  for (int i = 0; i < n; i++) {",
      "    Type x, y;",
      "    std::tie(x, y, std::ignore) = ExGcd(a, v[i].first);",
      "    Type g = a * x + v[i].first * y;",
      "    if ((v[i].second - r) % g != 0) return std::make_pair(-1, -1);",
      "    const Type p = v[i].first / g;",
      "    Type t = (x * ((v[i].second - r) / g)) % p;",
      "    if (t < 0) t += p;",
      "    r += t * a;",
      "    a *= p;",
      "  }",
      "  return std::make_pair(a, r);",
      "}",
      "",
      "}  // namespace ext"
    ]
  },
  "exgcd": {
    "prefix": "exgcd",
    "description": "exgcd",
    "body": [
      "namespace ext {",
      "",
      "// find a, b, g that a * x + b * y = g",
      "// g = gcd(x, y)",
      "// return std::tuple<a, b, g>",
      "template<typename Type = int64_t>",
      "std::tuple<Type, Type, Type> ExGcd(const Type& x, const Type& y) {",
      "  if (y == 0) return std::make_tuple(1, 0, x);",
      "  Type a, b, g;",
      "  std::tie(a, b, g) = ExGcd(y, x % y);",
      "  return std::make_tuple(b, a - x / y * b, g);",
      "}",
      "",
      "}  // namespace ext"
    ]
  },
  "modular": {
    "prefix": "modular",
    "description": "modular",
    "body": [
      "namespace ext {",
      "",
      "namespace detail {",
      "",
      "template <typename T>",
      "T inverse(T a, T m) {",
      "  T u = 0, v = 1;",
      "  while (a != 0) {",
      "    T t = m / a;",
      "    m -= t * a; std::swap(a, m);",
      "    u -= t * v; std::swap(u, v);",
      "  }",
      "  assert(m == 1);",
      "  return u;",
      "}",
      "",
      "}  // namespace detail",
      "",
      "template <typename T>",
      "class Modular {",
      " public:",
      "  using Type = typename std::decay<decltype(T::value)>::type;",
      "",
      "  constexpr Modular() : value() {}",
      "  template <typename U>",
      "  Modular(const U& x) {",
      "    value = normalize(x);",
      "  }",
      "",
      "  template <typename U>",
      "  static Type normalize(const U& x) {",
      "    Type v;",
      "    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);",
      "    else v = static_cast<Type>(x % mod());",
      "    if (v < 0) v += mod();",
      "    return v;",
      "  }",
      "",
      "  const Type& operator()() const { return value; }",
      "  template <typename U>",
      "  explicit operator U() const { return static_cast<U>(value); }",
      "  constexpr static Type mod() { return T::value; }",
      "",
      "  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }",
      "  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }",
      "  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }",
      "  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }",
      "  Modular& operator++() { return *this += 1; }",
      "  Modular& operator--() { return *this -= 1; }",
      "  Modular operator++(int) { Modular result(*this); *this += 1; return result; }",
      "  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }",
      "  Modular operator-() const { return Modular(-value); }",
      "",
      "  template <typename U = T>",
      "  typename std::enable_if<std::is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {",
      "#ifdef _WIN32",
      "    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);",
      "    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;",
      "    asm(",
      "      \"divl %4; \\n\\t\"",
      "      : \"=a\" (d), \"=d\" (m)",
      "      : \"d\" (xh), \"a\" (xl), \"r\" (mod())",
      "    );",
      "    value = m;",
      "#else",
      "    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));",
      "#endif",
      "    return *this;",
      "  }",
      "  template <typename U = T>",
      "  typename std::enable_if<std::is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {",
      "    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());",
      "    value = normalize(value * rhs.value - q * mod());",
      "    return *this;",
      "  }",
      "  template <typename U = T>",
      "  typename std::enable_if<!std::is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {",
      "    value = normalize(value * rhs.value);",
      "    return *this;",
      "  }",
      "",
      "  Modular& operator/=(const Modular& other) { return *this *= Modular(detail::inverse(other.value, mod())); }",
      "",
      "  template <typename U>",
      "  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);",
      "",
      "  template <typename U>",
      "  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);",
      "",
      "  template <typename U>",
      "  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);",
      "",
      " private:",
      "  Type value;",
      "};",
      "",
      "template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }",
      "template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }",
      "template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }",
      "",
      "template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }",
      "template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }",
      "template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }",
      "",
      "template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }",
      "",
      "template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }",
      "template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }",
      "template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }",
      "",
      "template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }",
      "template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }",
      "template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }",
      "",
      "template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }",
      "template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }",
      "template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }",
      "",
      "template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }",
      "template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }",
      "template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }",
      "",
      "template<typename T, typename U>",
      "Modular<T> power(const Modular<T>& a, const U& b) {",
      "  assert(b >= 0);",
      "  Modular<T> x = a, res = 1;",
      "  U p = b;",
      "  while (p > 0) {",
      "    if (p & 1) res *= x;",
      "    x *= x;",
      "    p >>= 1;",
      "  }",
      "  return res;",
      "}",
      "",
      "template <typename T>",
      "std::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {",
      "  return stream << number();",
      "}",
      "",
      "template <typename T>",
      "std::istream& operator>>(std::istream& stream, Modular<T>& number) {",
      "  typename std::common_type<typename Modular<T>::Type, int64_t>::type x;",
      "  stream >> x;",
      "  number.value = Modular<T>::normalize(x);",
      "  return stream;",
      "}",
      "",
      "constexpr int kMod = 1e9 + 7;",
      "using Int = Modular<std::integral_constant<std::decay<decltype(kMod)>::type, kMod>>;",
      "",
      "}  // namespace ext"
    ]
  },
  "qpow": {
    "prefix": "qpow",
    "description": "qpow",
    "body": [
      "namespace ext {",
      "",
      "template<typename T = int>",
      "int QPow(int a, T b, int mod) {",
      "  int ans = 1;",
      "  for (; b > 0; b >>= 1, a = 1ll * a * a % mod) {",
      "    if (b & 1) {",
      "      ans = 1ll * ans * a % mod;",
      "    }",
      "  }",
      "  return ans;",
      "}",
      "",
      "}  // namespace ext"
    ]
  },
  "rpn": {
    "prefix": "rpn",
    "description": "rpn",
    "body": [
      "namespace ext {",
      "",
      "// 表达式求值（内部采用后缀表达式求解）",
      "template <typename Type>",
      "class RPN {",
      " public:",
      "  // tuple<操作符, 优先级, 计算函数>",
      "  explicit RPN(const std::vector<std::tuple<char, int, std::function<Type(const Type&, const Type&)>>>& v)",
      "    : kLeftBucket(-1), kRightBucket(-2) {",
      "    for (const auto& o : v) {",
      "      dict_[std::get<0>(o)] = std::make_pair(std::get<1>(o), std::get<2>(o));",
      "    }",
      "    dict_['('] = std::make_pair(kLeftBucket, nullptr);",
      "    dict_[')'] = std::make_pair(kRightBucket, nullptr);",
      "  }",
      "  Type operator()(const std::string &str) {",
      "    const int n = str.size();",
      "    std::queue<Node> que;",
      "    std::stack<std::pair<int, char>> stk;",
      "    for(int i = 0; i < n; i++) {",
      "      if(isdigit(str[i])) {",
      "        Type cur = 0;",
      "        int j = i;",
      "        while(isdigit(str[j])) {",
      "          cur = cur * 10 + str[j] - '0';",
      "          j++;",
      "        }",
      "        i = j - 1;",
      "        que.push(Node('\\0', cur));",
      "      } else {",
      "        const int cur = Trans(str[i]);",
      "        if(cur == kLeftBucket) {",
      "          stk.emplace(cur, str[i]);",
      "        } else if(cur == kRightBucket) {",
      "          while(stk.top().second != kLeftBucket) {",
      "            que.push(Node(stk.top().second));",
      "            stk.pop();",
      "          }",
      "          stk.pop();",
      "        } else {",
      "          while(!stk.empty() && stk.top().first >= cur) {",
      "            que.push(Node(stk.top().second));",
      "            stk.pop();",
      "          }",
      "          stk.emplace(cur, str[i]);",
      "        }",
      "      }",
      "    }",
      "    while(!stk.empty()) {",
      "      que.push(Node(stk.top().second));",
      "      stk.pop();",
      "    }",
      "    std::stack<Type> for_calc;",
      "    while(!que.empty()) {",
      "      const Node cur = que.front();",
      "      que.pop();",
      "      if(cur.what_) {",
      "        const Type b = for_calc.top(); for_calc.pop();",
      "        const Type a = for_calc.top(); for_calc.pop();",
      "        for_calc.push(dict_.at(cur.what_).second(a, b));",
      "      } else {",
      "        for_calc.push(cur.val_);",
      "      }",
      "    }",
      "    return for_calc.top();",
      "  }",
      " private:",
      "  struct Node {",
      "    char what_;",
      "    Type val_;",
      "    Node(char w = '\\0', Type v = 0) : what_(w), val_(v) {}",
      "  };",
      "  const int kLeftBucket;",
      "  const int kRightBucket;",
      "  int Trans(const char c) {",
      "    return dict_.at(c).first;",
      "  }",
      "  std::map<char, std::pair<int, std::function<Type(const Type&, const Type&)>>> dict_;",
      "};",
      "",
      "RPN<int64_t> rpn_demo({",
      "  std::make_tuple('|', 11, [](const int64_t& x, const int64_t& y) { return x | y; }),",
      "  std::make_tuple('^', 12, [](const int64_t& x, const int64_t& y) { return x ^ y; }),",
      "  std::make_tuple('&', 13, [](const int64_t& x, const int64_t& y) { return x & y; }),",
      "  std::make_tuple('+', 14, [](const int64_t& x, const int64_t& y) { return x + y; }),",
      "  std::make_tuple('-', 14, [](const int64_t& x, const int64_t& y) { return x - y; }),",
      "  std::make_tuple('*', 15, [](const int64_t& x, const int64_t& y) { return x * y; }),",
      "  std::make_tuple('/', 15, [](const int64_t& x, const int64_t& y) { return x / y; }),",
      "  std::make_tuple('%', 15, [](const int64_t& x, const int64_t& y) { return x % y; }),",
      "});",
      "",
      "}  // namespace ext"
    ]
  },
  "leetcode": {
    "prefix": "leetcode",
    "description": "leetcode",
    "body": [
      "/**",
      " * @author yuzining",
      " * @date $CURRENT_YEAR/$CURRENT_MONTH/$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE",
      " */",
      "",
      "#ifdef LOCAL",
      "#include \"local.hpp\"",
      "using namespace std;",
      "#else",
      "#define DEBUG(...) do { } while(false)",
      "#endif",
      "",
      "",
      "",
      "#ifdef LOCAL",
      "int main() {",
      "",
      "}",
      "#endif"
    ]
  },
  "yuzining": {
    "prefix": "yuzining",
    "description": "yuzining",
    "body": [
      "/**",
      " * @author yuzining",
      " * @date $CURRENT_YEAR/$CURRENT_MONTH/$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE",
      " */",
      "",
      "#ifdef LOCAL",
      "#include \"local.hpp\"",
      "#else",
      "#include <bits/stdc++.h>",
      "#define DEBUG(...) do { } while (0)",
      "const int _______ = []() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); return 0; }();",
      "#endif",
      "",
      "int main() {",
      "",
      "}"
    ]
  },
  "kmp": {
    "prefix": "kmp",
    "description": "kmp",
    "body": [
      "namespace ext {",
      "",
      "std::vector<int> GetFail(const std::string& s) {",
      "  const int n = s.size();",
      "  std::vector<int> fail(n + 1);",
      "  for (int i = 0, j = fail[0] = -1; i < n; i++) {",
      "    while (j != -1 && s[j] != s[i]) {",
      "      j = fail[j];",
      "    }",
      "    fail[i + 1] = j + 1;",
      "  }",
      "  return fail;",
      "}",
      "",
      "int Match(const std::string& s, const std::string& t, std::vector<int> fail = std::vector<int>()) {",
      "  if (fail.empty()) {",
      "    fail = GetFail(t);",
      "  }",
      "  std::vector<int> ret;",
      "  const int n = s.size(), m = t.size();",
      "  for (int i = 0, j = 0; i < n; i++, j++) {",
      "    while (j != -1 && s[i] != t[j]) {",
      "      j = fail[j];",
      "    }",
      "    if (j + 1 == m) {",
      "      return i + 1 - m;",
      "    }",
      "  }",
      "  return -1;",
      "}",
      "",
      "std::vector<int> KMP(const std::string& s, const std::string& t, std::vector<int> fail = std::vector<int>()) {",
      "  if (fail.empty()) {",
      "    fail = GetFail(t);",
      "  }",
      "  std::vector<int> ret;",
      "  const int n = s.size(), m = t.size();",
      "  for (int i = 0, j = 0; i < n; i++, j++) {",
      "    while (j != -1 && s[i] != t[j]) {",
      "      j = fail[j];",
      "    }",
      "    if (j + 1 == m) {",
      "      ret.push_back(i + 1 - m);",
      "      j = -1;",
      "    }",
      "  }",
      "  return ret;",
      "}",
      "",
      "}  // namespace ext"
    ]
  },
  "manacher": {
    "prefix": "manacher",
    "description": "manacher",
    "body": [
      "namespace ext {",
      "",
      "class Manacher {",
      " public:",
      "  Manacher(const std::string& t) {",
      "    std::string s = \"$#\";",
      "    for (auto c : t) {",
      "      s += c, s += \"#\";",
      "    }",
      "    const int n = (int) s.length();",
      "    int ans = 0, ind = 0, right = 0;",
      "    dp_ = std::vector<int>(n, 1);",
      "    for (int i = 1; i < n; i++) {",
      "      if (i < right) {",
      "        dp_[i] = std::min(right - i, dp_[2 * ind - i]);",
      "      }",
      "      while (i + dp_[i] < n && s[i + dp_[i]] == s[i - dp_[i]]) {",
      "        ++dp_[i];",
      "      }",
      "      ans = std::max(ans, dp_[i] - 1);",
      "      if (i + dp_[i] > right) {",
      "        ind = i, right = i + dp_[i];",
      "      }",
      "    }",
      "    max_length_ = ans;",
      "  }",
      "  int GetMaxLength() {",
      "    return max_length_;",
      "  }",
      "  bool CheckIsPalindrome(int from, int to) {",
      "    from++;",
      "    to++;",
      "    return dp_[from + to] - 1 >= to - from + 1;",
      "  }",
      " private:",
      "  std::vector<int> dp_;",
      "  int max_length_;",
      "};",
      "",
      "}  // namespace ext"
    ]
  },
  "replace": {
    "prefix": "replace",
    "description": "replace",
    "body": [
      "namespace ext {",
      "",
      "std::string Replace(const std::string& str, const std::string& from, const std::string& to) {",
      "  std::vector<int> ids = KMP(str, from);",
      "  std::string ret;",
      "  ids.push_back(static_cast<int>(str.size()));",
      "  int cur = 0;",
      "  const int size = ids.size();",
      "  for (int i = 0; i < size; i++) {",
      "    // from = cur, to = ids[i] - 1",
      "    ret.append(str.substr(cur, ids[i] - cur));",
      "    if (i + 1 < size) {",
      "      ret.append(to);",
      "    }",
      "    cur = ids[i] + from.size();",
      "  }",
      "  return ret;",
      "}",
      "",
      "}  // namespace ext"
    ]
  },
  "split": {
    "prefix": "split",
    "description": "split",
    "body": [
      "namespace ext {",
      "",
      "std::vector<std::string> Split(const std::string& str, const std::string& split_str = \" \", bool ignore_empty = false) {",
      "  std::vector<int> ids = KMP(str, split_str);",
      "  ids.push_back(static_cast<int>(str.size()));",
      "  std::vector<std::string> ret;",
      "  int cur = 0;",
      "  const int size = ids.size();",
      "  for (int i = 0; i < size; i++) {",
      "    // from = cur, to = ids[i] - 1",
      "    if ((ignore_empty && ids[i] > cur) || !ignore_empty) {",
      "      ret.push_back(str.substr(cur, ids[i] - cur));",
      "    }",
      "    cur = ids[i] + split_str.size();",
      "  }",
      "  return ret;",
      "}",
      "",
      "}  // namespace ext"
    ]
  },
  "z_function": {
    "prefix": "z_function",
    "description": "z_function",
    "body": [
      "namespace ext {",
      "",
      "std::vector<int> z_function(std::string s) {",
      "  const int n = s.size();",
      "  std::vector<int> z(n);",
      "  for (int i = 1, l = 0, r = 0; i < n; i++) {",
      "    if (i <= r) z[i] = std::min(r - i + 1, z[i - l]);",
      "    while (i + z[i] < n && s[z[i]] == s[i + z[i]]) ++z[i];",
      "    if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;",
      "  }",
      "  return z;",
      "}",
      "",
      "}  // namespace ext"
    ]
  },
  "local": {
    "prefix": "local",
    "description": "local",
    "body": [
      "template <typename F, typename S>",
      "std::ostream& operator << (std::ostream& s, const std::pair<F, S>& p);",
      "template <typename T, typename A>",
      "std::ostream& operator << (std::ostream& s, const std::vector<T, A>& a);",
      "template <typename T, typename A>",
      "std::ostream& operator << (std::ostream& s, const std::set<T, A>& a);",
      "template <typename T, typename H, typename P, typename A>",
      "std::ostream& operator << (std::ostream& s, const std::unordered_set<T, H, P, A>& a);",
      "template <typename K, typename T, typename C, typename A>",
      "std::ostream& operator << (std::ostream& s, const std::map<K, T, C, A>& a);",
      "template <typename K, typename T, typename H, typename P, typename A>",
      "std::ostream& operator << (std::ostream& s, const std::unordered_map<K, T, H, P, A>& a);",
      "template <typename ...Args>",
      "std::ostream& operator << (std::ostream& s, const std::tuple<Args...>& p);",
      "template <typename F, typename S>",
      "std::ostream& operator << (std::ostream& s, const std::pair<F, S>& p) {",
      "  s << '<' << p.first << \", \" << p.second << '>';",
      "  return s;",
      "}",
      "template <typename T, typename A>",
      "std::ostream& operator << (std::ostream& s, const std::vector<T, A>& a) {",
      "  s << '[';",
      "  for (size_t i = 0; i < a.size(); i++) {",
      "    s << a[i];",
      "    if (i + 1 < a.size()) {",
      "      s << \", \";",
      "    }",
      "  }",
      "  s << ']';",
      "  return s;",
      "}",
      "template <typename T, typename A>",
      "std::ostream& operator << (std::ostream& s, const std::set<T, A>& a) {",
      "  s << '{';",
      "  bool i = false;",
      "  for (const auto &x : a) {",
      "    if (i) {",
      "      s << \", \";",
      "    }",
      "    s << x;",
      "    i = true;",
      "  }",
      "  s << '}';",
      "  return s;",
      "}",
      "template <typename T, typename H, typename P, typename A>",
      "std::ostream& operator << (std::ostream& s, const std::unordered_set<T, H, P, A>& a) {",
      "  s << '{';",
      "  bool i = false;",
      "  for (const auto &x : a) {",
      "    if (i) {",
      "      s << \", \";",
      "    }",
      "    s << x;",
      "    i = true;",
      "  }",
      "  s << '}';",
      "  return s;",
      "}",
      "template <typename K, typename T, typename C, typename A>",
      "std::ostream& operator << (std::ostream& s, const std::map<K, T, C, A>& a) {",
      "  s << '{';",
      "  bool i = false;",
      "  for (const auto &[x, y] : a) {",
      "    if (i) {",
      "      s << \", \";",
      "    }",
      "    s << '{' << x << \": \" << y << '}';",
      "    i = true;",
      "  }",
      "  s << '}';",
      "  return s;",
      "}",
      "template <typename K, typename T, typename H, typename P, typename A>",
      "std::ostream& operator << (std::ostream& s, const std::unordered_map<K, T, H, P, A>& a) {",
      "  s << '{';",
      "  bool i = false;",
      "  for (const auto &[x, y] : a) {",
      "    if (i) {",
      "      s << \", \";",
      "    }",
      "    s << '{' << x << \": \" << y << '}';",
      "    i = true;",
      "  }",
      "  s << '}';",
      "  return s;",
      "}",
      "namespace __debug_detail {",
      "template <int pos, typename ...Args>",
      "struct __TuplePrinter {",
      "  static std::ostream& __print_tuple(std::ostream& s, const std::tuple<Args...>& p, int size) {",
      "    __TuplePrinter<pos - 1, Args...>::__print_tuple(s, p, size);",
      "    s << std::get<pos>(p);",
      "    if (pos + 1 != size) {",
      "      s << \", \";",
      "    }",
      "    return s;",
      "  }",
      "};",
      "template <typename ...Args>",
      "struct __TuplePrinter<0, Args...> {",
      "  static std::ostream& __print_tuple(std::ostream& s, const std::tuple<Args...>& p, int size) {",
      "    s << std::get<0>(p);",
      "    if (0 + 1 != size) {",
      "      s << \", \";",
      "    }",
      "    return s;",
      "  }",
      "};",
      "}",
      "template <typename ...Args>",
      "std::ostream& operator << (std::ostream& s, const std::tuple<Args...>& p) {",
      "  constexpr int size = std::tuple_size<std::tuple<Args...>>{};",
      "  s << '<';",
      "  __debug_detail::__TuplePrinter<size - 1, Args...>::__print_tuple(s, p, size);",
      "  s << '>';",
      "  return s;",
      "}",
      "namespace __debug_detail {",
      "void _print() {}",
      "template <typename T, typename... U>",
      "void _print(const T &head, const U &...tail) {",
      "  std::cout << head << (sizeof...(tail) ? ' ' : '\\n');",
      "  _print(tail...);",
      "}",
      "}",
      "#define DEBUG(...) __debug_detail::_print(__VA_ARGS__)"
    ]
  }
}