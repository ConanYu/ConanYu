{"io": {"prefix": "io", "description": "io", "body": ["namespace ext {", "namespace detail {", "  const size_t buflen = (1 << 21) + 1;", "  char buf[buflen], *st = nullptr, *ed = nullptr;", "  inline char gc() { return ((st == ed) ? (st = buf, ed = st + fread(buf, 1, buflen, stdin), (st == ed) ? EOF : *st++) : *st++); }", "  inline bool blank(char c) { return c == ' ' || c == '-' || c == '\\n' || c == '\\t' || c == '\\r'; }", "  template <typename T> inline bool Re(T &x) {", "    char c; int f = 1;", "    while (blank(c = gc())) if (c == '-') f = -1;", "    if (c == EOF) return false;", "    for (x = c - '0'; (c = gc()) >= '0' && c <= '9'; x = x * 10 + c - '0');", "    x *= f; return true;", "  }", "  char obuf[buflen], *_ptr = obuf, *_oed = obuf + buflen - 1, _stk[55];", "  int _top;", "  void flush() { fwrite(obuf, 1, _ptr - obuf, stdout); _ptr = obuf;}", "  void pc(char c) { *(_ptr++) = c; if (_ptr == _oed) flush(); }", "  template <typename T> inline void Pr(T x) {", "    if (x == 0) { pc('0'); return; }", "    if (x < 0) { pc('-'); x = -x; }", "    for (_top = 0; x > 0; _top++, x /= 10) _stk[_top] = (x % 10) + '0';", "    while (_top > 0) pc(_stk[--_top]);", "  }", "  template <typename T> inline void Prln(T x) { Pr(x); pc('\\n'); }", "  struct _IOflusher_ { ~_IOflusher_() { flush(); } } __flusher__;", "}  // namespace detail", "struct instream {", "  instream &operator>>(char &__n) { __n = detail::gc(); return *this; }", "  instream &operator>>(unsigned char &__n) { __n = detail::gc(); return *this; }", "  instream &operator>>(short &__n) { detail::Re(__n); return *this; }", "  instream &operator>>(unsigned short &__n) { detail::Re(__n); return *this; }", "  instream &operator>>(int &__n) { detail::Re(__n); return *this; }", "  instream &operator>>(unsigned int &__n) { detail::Re(__n); return *this; }", "  instream &operator>>(long &__n) { detail::Re(__n); return *this; }", "  instream &operator>>(unsigned long &__n) { detail::Re(__n); return *this; }", "  instream &operator>>(long long &__n) { detail::Re(__n); return *this; }", "  instream &operator>>(unsigned long long &__n) { detail::Re(__n); return *this; }", "#ifdef __SIZEOF_INT128__", "  instream &operator>>(__int128 &__n) { detail::Re(__n); return *this;}", "  instream &operator>>(__uint128_t &__n) { detail::Re(__n); return *this; }", "#endif", "  instream &operator>>(std::string &__n) {", "    __n.clear();", "    char c = detail::gc();", "    if(c == EOF) return *this;", "    while(c != EOF && detail::blank(c)) c = detail::gc();", "    if(c == EOF) return *this;", "    while(c != EOF && !detail::blank(c)) {", "      __n.push_back(c);", "      c = detail::gc();", "    }", "    if(c != EOF) detail::st--;", "    return *this;", "  }", "} in;", "struct outstream {", "  outstream &operator<<(const char &__n) { detail::pc(__n); return *this; }", "  outstream &operator<<(const unsigned char &__n) { detail::pc(__n); return *this; }", "  outstream &operator<<(const short &__n) { detail::Pr(__n); return *this; }", "  outstream &operator<<(const unsigned short &__n) { detail::Pr(__n); return *this; }", "  outstream &operator<<(const int &__n) { detail::Pr(__n); return *this; }", "  outstream &operator<<(const unsigned int &__n) { detail::Pr(__n); return *this; }", "  outstream &operator<<(const long &__n) { detail::Pr(__n); return *this; }", "  outstream &operator<<(const unsigned long &__n) { detail::Pr(__n); return *this; }", "  outstream &operator<<(const long long &__n) { detail::Pr(__n); return *this; }", "  outstream &operator<<(const unsigned long long &__n) { detail::Pr(__n); return *this; }", "#ifdef __SIZEOF_INT128__", "  outstream &operator<<(const __int128 &__n) { detail::Pr(__n); return *this; }", "  outstream &operator<<(const __uint128_t &__n) { detail::Pr(__n); return *this; }", "#endif", "  outstream &operator<<(const std::string &__n) {", "    for(const char &__c: __n) detail::pc(__c);", "    return *this;", "  }", "} out;", "}  // namespace ext"]}, "dsu": {"prefix": "dsu", "description": "dsu", "body": ["namespace ext {", "", "// \u5e76\u67e5\u96c6", "class Dsu {", " public:", "  std::vector<int> anc, size;", "  Dsu(int n) : anc(n), size(n, 0) {", "    std::iota(anc.begin(), anc.end(), 0);", "  }", "  int operator[] (int x) {", "    return x == anc[x] ? x : anc[x] = operator[](anc[x]);", "  }", "  bool operator() (int u, int v) {", "    int a = operator[](u), b = operator[](v);", "    if (a == b) return false;", "    if (size[a] < size[b]) anc[a] = b;", "    else anc[b] = a, size[a] += (size[a] == size[b]);", "    return true;", "  }", "};", "", "}  // namespace ext"]}, "fenwick_tree": {"prefix": "fenwick_tree", "description": "fenwick_tree", "body": ["namespace ext {", "", "// \u6811\u72b6\u6570\u7ec4", "// index from 1", "template<typename Type = int>", "class FenwickTree {", " public:", "  FenwickTree(const int size) {", "    std::vector<Type> vec(size, Type());", "    Init(vec);", "  }", "  FenwickTree(const int size, const Type& init_value) {", "    std::vector<Type> vec(size, init_value);", "    Init(vec);", "  }", "  FenwickTree(const std::vector<Type>& vec) {", "    Init(vec);", "  }", "  void Add(int position, const Type& value) {", "    for (int i = position; i <= n_; i += i & (-i)) {", "      fenwick_tree_[i] += value;", "    }", "  }", "  Type Query(int index) const {", "    Type ret = Type();", "    for (int i = index; i > 0; i -= i & (-i)) {", "      ret += fenwick_tree_[i];", "    }", "    return ret;", "  }", "  Type Query(int left, int right) const {", "    return Query(right) - Query(left - 1);", "  }", " private:", "  void Init(const std::vector<Type>& vec) {", "    n_ = vec.size();", "    fenwick_tree_.resize(vec.size() + 1);", "    for (int i = 1; i <= n_; i++) {", "      Add(i, vec[i - 1]);", "    }", "  }", "  int n_;", "  std::vector<Type> fenwick_tree_;", "};", "", "}  // namespace ext"]}, "s_table": {"prefix": "s_table", "description": "s_table", "body": ["namespace ext {", "", "namespace detail {", "", "template <typename Type, typename Comp = std::less<Type>>", "class InnerMerger {", " public:", "  Type operator()(const Type& lhs, const Type& rhs) const {", "    return cmp(lhs, rhs) ? lhs : rhs;", "  }", " private:", "  const Comp cmp;", "};", "", "}  // namespace detail", "", "template<typename Type, typename Merger = detail::InnerMerger<Type>>", "class STable {", " public:", "  explicit STable(const vector<Type>& arr) : merger() {", "    const int n = static_cast<int>(arr.size());", "    table.assign(n, vector<Type>(Log2(n) + 1));", "    for (int i = 0; i < n; i++) {", "      table[i][0] = arr[i];", "    }", "    for (int j = 1; (1 << j) <= n; j++) {", "      for (int i = 0; i + (1 << j) - 1 < n; i++) {", "        const Type x = table[i][j - 1], y = table[i + (1 << (j - 1))][j - 1];", "        table[i][j] = merger(x, y);", "      }", "    }", "  }", "  Type Query(int l, int r) const {", "    const int k = Log2(r - l + 1);", "    const Type x = table[l][k], y = table[r - (1 << k) + 1][k];", "    return merger(x, y);", "  }", "  Type operator()(int l, int r) const {", "    return Query(l, r);", "  }", " private:", "  int Log2(int n) const {", "    return 31 - __builtin_clz(static_cast<unsigned int>(n));", "  }", "  const Merger merger;", "  std::vector<std::vector<Type>> table;", "};", "", "}  // namespace ext"]}, "combine": {"prefix": "combine", "description": "combine", "body": ["namespace ext {", "", "class Combine {", " public:", "  Combine(int mod, int max_size) : mod_(mod), max_size_(max_size + 5) {", "    fac_.resize(max_size_);", "    inv_.resize(max_size_);", "    fac_[0] = 1;", "    for (int i = 1; i < max_size_; i++) {", "      fac_[i] = 1ll * fac_[i - 1] * i % mod;", "    }", "    inv_[max_size_ - 1] = std::get<0>(ExGcd(fac_[max_size_ - 1], mod_));", "    if (inv_[max_size_ - 1] < 0) {", "      inv_[max_size_ - 1] += mod_;", "    }", "    for (int i = max_size_ - 2; i >= 0; i--) {", "      inv_[i] = 1ll * inv_[i + 1] * (i + 1) % mod_;", "    }", "  }", "  int GetFac(int index) {", "    return fac_[index];", "  }", "  int GetInv(int index) {", "    return inv_[index];", "  }", "  int operator()(int n, int m) {", "    return 1ll * fac_[n] * inv_[m] % mod_ * inv_[n - m] % mod_;", "  }", " private:", "  const int mod_;", "  const int max_size_;", "  std::vector<int> fac_, inv_;", "};", "", "}  // namespace ext"]}, "crt": {"prefix": "crt", "description": "crt", "body": ["namespace ext {", "", "// v\u91cc\u6bcf\u4e2astd::pair<Type, Type>\u4e2dfirst\u4e3a\u88ab\u6a21\u6570\uff0csecond\u4e3a\u6a21\u6570", "template<typename Type>", "std::pair<Type, Type> Crt(const std::vector<std::pair<Type, Type>>& v) {", "  Type a = 1, r = 0;", "  const int n = v.size();", "  for (int i = 0; i < n; i++) {", "    Type x, y;", "    std::tie(x, y, std::ignore) = ExGcd(a, v[i].first);", "    Type g = a * x + v[i].first * y;", "    if ((v[i].second - r) % g != 0) return std::make_pair(-1, -1);", "    const Type p = v[i].first / g;", "    Type t = (x * ((v[i].second - r) / g)) % p;", "    if (t < 0) t += p;", "    r += t * a;", "    a *= p;", "  }", "  return std::make_pair(a, r);", "}", "", "}  // namespace ext"]}, "exgcd": {"prefix": "exgcd", "description": "exgcd", "body": ["namespace ext {", "", "// find a, b, g that a * x + b * y = g", "// g = gcd(x, y)", "// return std::tuple<a, b, g>", "template<typename Type = int64_t>", "std::tuple<Type, Type, Type> ExGcd(const Type& x, const Type& y) {", "  if (y == 0) return std::make_tuple(1, 0, x);", "  Type a, b, g;", "  std::tie(a, b, g) = ExGcd(y, x % y);", "  return std::make_tuple(b, a - x / y * b, g);", "}", "", "}  // namespace ext"]}, "modular": {"prefix": "modular", "description": "modular", "body": ["namespace ext {", "", "namespace detail {", "", "template <typename T>", "T inverse(T a, T m) {", "  T u = 0, v = 1;", "  while (a != 0) {", "    T t = m / a;", "    m -= t * a; std::swap(a, m);", "    u -= t * v; std::swap(u, v);", "  }", "  assert(m == 1);", "  return u;", "}", "", "}  // namespace detail", "", "template <typename T>", "class Modular {", " public:", "  using Type = typename std::decay<decltype(T::value)>::type;", "", "  constexpr Modular() : value() {}", "  template <typename U>", "  Modular(const U& x) {", "    value = normalize(x);", "  }", "", "  template <typename U>", "  static Type normalize(const U& x) {", "    Type v;", "    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);", "    else v = static_cast<Type>(x % mod());", "    if (v < 0) v += mod();", "    return v;", "  }", "", "  const Type& operator()() const { return value; }", "  template <typename U>", "  explicit operator U() const { return static_cast<U>(value); }", "  constexpr static Type mod() { return T::value; }", "", "  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }", "  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }", "  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }", "  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }", "  Modular& operator++() { return *this += 1; }", "  Modular& operator--() { return *this -= 1; }", "  Modular operator++(int) { Modular result(*this); *this += 1; return result; }", "  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }", "  Modular operator-() const { return Modular(-value); }", "", "  template <typename U = T>", "  typename std::enable_if<std::is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {", "#ifdef _WIN32", "    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);", "    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;", "    asm(", "      \"divl %4; \\n\\t\"", "      : \"=a\" (d), \"=d\" (m)", "      : \"d\" (xh), \"a\" (xl), \"r\" (mod())", "    );", "    value = m;", "#else", "    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));", "#endif", "    return *this;", "  }", "  template <typename U = T>", "  typename std::enable_if<std::is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {", "    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());", "    value = normalize(value * rhs.value - q * mod());", "    return *this;", "  }", "  template <typename U = T>", "  typename std::enable_if<!std::is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {", "    value = normalize(value * rhs.value);", "    return *this;", "  }", "", "  Modular& operator/=(const Modular& other) { return *this *= Modular(detail::inverse(other.value, mod())); }", "", "  template <typename U>", "  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);", "", "  template <typename U>", "  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);", "", "  template <typename U>", "  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);", "", " private:", "  Type value;", "};", "", "template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }", "template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }", "template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }", "", "template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }", "template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }", "template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }", "", "template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }", "", "template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }", "template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }", "template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }", "", "template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }", "template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }", "template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }", "", "template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }", "template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }", "template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }", "", "template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }", "template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }", "template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }", "", "template<typename T, typename U>", "Modular<T> power(const Modular<T>& a, const U& b) {", "  assert(b >= 0);", "  Modular<T> x = a, res = 1;", "  U p = b;", "  while (p > 0) {", "    if (p & 1) res *= x;", "    x *= x;", "    p >>= 1;", "  }", "  return res;", "}", "", "template <typename T>", "std::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {", "  return stream << number();", "}", "", "template <typename T>", "std::istream& operator>>(std::istream& stream, Modular<T>& number) {", "  typename std::common_type<typename Modular<T>::Type, int64_t>::type x;", "  stream >> x;", "  number.value = Modular<T>::normalize(x);", "  return stream;", "}", "", "constexpr int kMod = 1e9 + 7;", "using Int = Modular<std::integral_constant<std::decay<decltype(kMod)>::type, kMod>>;", "", "}  // namespace ext"]}, "qpow": {"prefix": "qpow", "description": "qpow", "body": ["namespace ext {", "", "template<typename T = int>", "int QPow(int a, T b, int mod) {", "  int ans = 1;", "  for (; b > 0; b >>= 1, a = 1ll * a * a % mod) {", "    if (b & 1) {", "      ans = 1ll * ans * a % mod;", "    }", "  }", "  return ans;", "}", "", "}  // namespace ext"]}, "rpn": {"prefix": "rpn", "description": "rpn", "body": ["namespace ext {", "", "// \u8868\u8fbe\u5f0f\u6c42\u503c\uff08\u5185\u90e8\u91c7\u7528\u540e\u7f00\u8868\u8fbe\u5f0f\u6c42\u89e3\uff09", "template <typename Type>", "class RPN {", " public:", "  // tuple<\u64cd\u4f5c\u7b26, \u4f18\u5148\u7ea7, \u8ba1\u7b97\u51fd\u6570>", "  explicit RPN(const std::vector<std::tuple<char, int, std::function<Type(const Type&, const Type&)>>>& v)", "    : kLeftBucket(-1), kRightBucket(-2) {", "    for (const auto& o : v) {", "      dict_[std::get<0>(o)] = std::make_pair(std::get<1>(o), std::get<2>(o));", "    }", "  }", "  Type operator()(const std::string &str) {", "    const int n = str.size();", "    std::queue<Node> que;", "    std::stack<std::pair<int, char>> stk;", "    for(int i = 0; i < n; i++) {", "      if(isdigit(str[i])) {", "        Type cur = 0;", "        int j = i;", "        while(isdigit(str[j])) {", "          cur = cur * 10 + str[j] - '0';", "          j++;", "        }", "        i = j - 1;", "        que.push(Node('\\0', cur));", "      } else {", "        const int cur = Trans(str[i]);", "        if(cur == kLeftBucket) {", "          stk.emplace(cur, str[i]);", "        } else if(cur == kRightBucket) {", "          while(stk.top().second != kLeftBucket) {", "            que.push(Node(stk.top().second));", "            stk.pop();", "          }", "          stk.pop();", "        } else {", "          while(!stk.empty() && stk.top().first >= cur) {", "            que.push(Node(stk.top().second));", "            stk.pop();", "          }", "          stk.emplace(cur, str[i]);", "        }", "      }", "    }", "    while(!stk.empty()) {", "      que.push(Node(stk.top().second));", "      stk.pop();", "    }", "    std::stack<Type> for_calc;", "    while(!que.empty()) {", "      const Node cur = que.front();", "      que.pop();", "      if(cur.what_) {", "        const Type b = for_calc.top(); for_calc.pop();", "        const Type a = for_calc.top(); for_calc.pop();", "        for_calc.push(dict_.at(cur.what_).second(a, b));", "      } else {", "        for_calc.push(cur.val_);", "      }", "    }", "    return for_calc.top();", "  }", " private:", "  struct Node {", "    char what_;", "    Type val_;", "    Node(char w = '\\0', Type v = 0) : what_(w), val_(v) {}", "  };", "  const int kLeftBucket;", "  const int kRightBucket;", "  int Trans(const char c) {", "    return dict_.at(c).first;", "  }", "  std::map<char, std::pair<int, std::function<Type(const Type&, const Type&)>>> dict_;", "};", "", "RPN<int64_t> rpn_demo({", "  std::make_tuple('|', 11, [](const int64_t& x, const int64_t& y) { return x | y; }),", "  std::make_tuple('^', 12, [](const int64_t& x, const int64_t& y) { return x ^ y; }),", "  std::make_tuple('&', 13, [](const int64_t& x, const int64_t& y) { return x & y; }),", "  std::make_tuple('+', 14, [](const int64_t& x, const int64_t& y) { return x + y; }),", "  std::make_tuple('-', 14, [](const int64_t& x, const int64_t& y) { return x - y; }),", "  std::make_tuple('*', 15, [](const int64_t& x, const int64_t& y) { return x * y; }),", "  std::make_tuple('/', 15, [](const int64_t& x, const int64_t& y) { return x / y; }),", "  std::make_tuple('%', 15, [](const int64_t& x, const int64_t& y) { return x % y; }),", "});", "", "}  // namespace ext"]}, "leetcode": {"prefix": "leetcode", "description": "leetcode", "body": ["/**", " * @author yuzining", " * @date $CURRENT_YEAR/$CURRENT_MONTH/$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE\"", " */", "", "#ifdef local", "# include \"D:\\VSCODE\\local.hpp\"", "template<typename T>", "ostream &operator<<(ostream &out, const vector<T> &vec) {", "  bool isPrint = false;", "  for (auto &x : vec) {", "    out << (isPrint ? ',' : '[') << x;", "    isPrint = true;", "  }", "  out << ']';", "  return out;", "}", "#else", "#define debug(...) do { } while(false)", "#endif", "", "", "", "#ifdef local", "void Main() {", "  Solution o;", "  cout << o.solve(xxx) << '\\n';", "}", "#endif"]}, "yuzining": {"prefix": "yuzining", "description": "yuzining", "body": ["/**", " * @author yuzining", " * @date $CURRENT_YEAR/$CURRENT_MONTH/$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE", " */", "", "#ifdef local", "#include \"D:\\VSCODE\\debug.hpp\"", "#else", "#include <bits/stdc++.h>", "#define DEBUG(...) do { } while (0)", "const int _______ = []() { std::ios::sync_with_stdio(false), std::cin.tie(nullptr); return 0; }();", "#endif", "", "int main() {", "", "}"]}, "kmp": {"prefix": "kmp", "description": "kmp", "body": ["namespace ext {", "", "std::vector<int> GetFail(const std::string& s) {", "  const int n = s.size();", "  std::vector<int> fail(n + 1);", "  for (int i = 0, j = fail[0] = -1; i < n; i++) {", "    while (j != -1 && s[j] != s[i]) {", "      j = fail[j];", "    }", "    fail[i + 1] = j + 1;", "  }", "  return fail;", "}", "", "int Match(const std::string& s, const std::string& t, std::vector<int> fail = std::vector<int>()) {", "  if (fail.empty()) {", "    fail = GetFail(t);", "  }", "  std::vector<int> ret;", "  const int n = s.size(), m = t.size();", "  for (int i = 0, j = 0; i < n; i++, j++) {", "    while (j != -1 && s[i] != t[j]) {", "      j = fail[j];", "    }", "    if (j + 1 == m) {", "      return i + 1 - m;", "    }", "  }", "  return -1;", "}", "", "std::vector<int> KMP(const std::string& s, const std::string& t, std::vector<int> fail = std::vector<int>()) {", "  if (fail.empty()) {", "    fail = GetFail(t);", "  }", "  std::vector<int> ret;", "  const int n = s.size(), m = t.size();", "  for (int i = 0, j = 0; i < n; i++, j++) {", "    while (j != -1 && s[i] != t[j]) {", "      j = fail[j];", "    }", "    if (j + 1 == m) {", "      ret.push_back(i + 1 - m);", "      j = -1;", "    }", "  }", "  return ret;", "}", "", "}  // namespace ext"]}, "manacher": {"prefix": "manacher", "description": "manacher", "body": ["namespace ext {", "", "class Manacher {", " public:", "  Manacher(const std::string& t) {", "    std::string s = \"$#\";", "    for (auto c : t) {", "      s += c, s += \"#\";", "    }", "    const int n = (int) s.length();", "    int ans = 0, ind = 0, right = 0;", "    dp_ = std::vector<int>(n, 1);", "    for (int i = 1; i < n; i++) {", "      if (i < right) {", "        dp_[i] = std::min(right - i, dp_[2 * ind - i]);", "      }", "      while (i + dp_[i] < n && s[i + dp_[i]] == s[i - dp_[i]]) {", "        ++dp_[i];", "      }", "      ans = std::max(ans, dp_[i] - 1);", "      if (i + dp_[i] > right) {", "        ind = i, right = i + dp_[i];", "      }", "    }", "    max_length_ = ans;", "  }", "  int GetMaxLength() {", "    return max_length_;", "  }", "  // index start from 1", "  bool CheckIsPalindrome(int from, int to) {", "    return dp_[from + to] - 1 >= from - to + 1;", "  }", " private:", "  std::vector<int> dp_;", "  int max_length_;", "};", "", "}  // namespace ext"]}, "replace": {"prefix": "replace", "description": "replace", "body": ["namespace ext {", "", "std::string Replace(const std::string& str, const std::string& from, const std::string& to) {", "  std::vector<int> ids = KMP(str, from);", "  std::string ret;", "  ids.push_back(static_cast<int>(str.size()));", "  int cur = 0;", "  const int size = ids.size();", "  for (int i = 0; i < size; i++) {", "    // from = cur, to = ids[i] - 1", "    ret.append(str.substr(cur, ids[i] - cur));", "    if (i + 1 < size) {", "      ret.append(to);", "    }", "    cur = ids[i] + from.size();", "  }", "  return ret;", "}", "", "}  // namespace ext"]}, "split": {"prefix": "split", "description": "split", "body": ["namespace ext {", "", "std::vector<std::string> Split(const std::string& str, const std::string& split_str = \" \", bool ignore_empty = false) {", "  std::vector<int> ids = KMP(str, split_str);", "  ids.push_back(static_cast<int>(str.size()));", "  std::vector<std::string> ret;", "  int cur = 0;", "  const int size = ids.size();", "  for (int i = 0; i < size; i++) {", "    // from = cur, to = ids[i] - 1", "    if ((ignore_empty && ids[i] > cur) || !ignore_empty) {", "      ret.push_back(str.substr(cur, ids[i] - cur));", "    }", "    cur = ids[i] + split_str.size();", "  }", "  return ret;", "}", "", "}  // namespace ext"]}, "z_function": {"prefix": "z_function", "description": "z_function", "body": ["namespace ext {", "", "std::vector<int> z_function(std::string s) {", "  const int n = s.size();", "  std::vector<int> z(n);", "  for (int i = 1, l = 0, r = 0; i < n; i++) {", "    if (i <= r) z[i] = std::min(r - i + 1, z[i - l]);", "    while (i + z[i] < n && s[z[i]] == s[i + z[i]]) ++z[i];", "    if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;", "  }", "  return z;", "}", "", "}  // namespace ext"]}}